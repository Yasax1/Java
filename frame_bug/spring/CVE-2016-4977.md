# 简介

SpringSecurity是一个流行的权限管理框架，类似Shiro，但功能更加完善。在Spring Security OAuth2的漏洞版本中，当用户使用`whitelabel views`来处理错误时，由于递归解析了SpEL表达式，攻击者在被授权的情况下可以通过构造恶意参数来RCE。(感觉跟S2-001有相似的地方)

# 影响版本

- 2.0.0 to 2.0.9
- 1.0.0 to 1.0.5

# 环境搭建&复现

下载Demo代码：http://secalert.net/research/cve-2016-4977.zip

观察启动文件：`resources/application.properties`，观察到clientId是acme，密码是password

启动并访问url：`http://localhost:8080/oauth/authorize?response_type=token&client_id=acme&redirect_uri=hello`

输入用户名:user 密码:password

![image-20210908191423573](CVE-2016-4977/image-20210908191423573.png)

修改url:http://localhost:8080/oauth/authorize?response_type=token&client_id=acme&redirect_uri=${2334-1}

![image-20210908191622224](CVE-2016-4977/image-20210908191622224.png)

这里将uri改为了SpEL表达式,发现被解析。那么我们进一步的将uri改成我们的payload:`${new%20java.lang.ProcessBuilder(new%20java.lang.String(new%20byte[]{99,97,108,99})).start()}` 成功弹出计算器



# OAuth2

OAuth 2.0是用于授权的行业标准协议，核心思路是通过各类认证手段（具体什么手段OAuth 2.0不关心）认证用户身份，并颁发token，使得第三方应用可以使用该token在限定时间、限定范围内访问指定资源。OAuth 2.0致力于简化客户端开发人员的工作，同时为Web应用程序、桌面应用程序、移动电话和客厅设备提供特定的授权流程。

OAuth在”客户端”与”服务提供商”之间，设置了一个授权层（authorization layer）。”客户端”不能直接登录”服务提供商”，只能登录授权层，以此将用户与客户端区分开来。”客户端”登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。

“客户端”登录授权层以后，”服务提供商”根据令牌的权限范围和有效期，向”客户端”开放用户储存的资料。

校验流程如图：

![img](CVE-2016-4977/4.png)

具体的讲解可参考：[《理解OAuth 2.0》](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html)

# Spring Security OAuth2

Spring Security OAuth2是为Spring框架提供安全认证支持的一个模块，主要包含认证服务器和资源服务器这两大块的实现：

Spring Security OAuth2主要包含认证服务器和资源服务器这两大块的实现：

![img](CVE-2016-4977/5.png)

认证服务器主要包含了四种授权模式的实现和Token的生成与存储，我们也可以在认证服务器中自定义获取Token的方式；资源服务器主要是在Spring Security的过滤器链上加了OAuth2AuthenticationProcessingFilter过滤器，即使用OAuth2协议发放令牌认证的方式来保护我们的资源。

# 漏洞分析

由于程序使用WhiteLabel视图来做返回页面，所以首先分析下面这个文件：`org\springframework\security\oauth2\provider\endpoint\WhitelabelErrorEndpoint.java`

可以看到程序通过 oauthError.getSummary() 来获取错误信息

![image-20210908212659756](CVE-2016-4977/image-20210908212659756.png)

然后跟进new SpelView(),这里进行了一系列初始化

![image-20210908213052331](CVE-2016-4977/image-20210908213052331.png)



下面有一个render方法,将map传入了我们的上下文中,map中包含我们的报错信息。然后进入replacePlaceholders方法

![image-20210908213513030](CVE-2016-4977/image-20210908213513030.png)



这里调用了parseStringValue方法

该方法会进行一个递归查询

递归调用导致`${xxx${payload}xxx}`这样的payload可以被解析到。

![image-20210908213641291](CVE-2016-4977/image-20210908213641291.png)

上面会判断&{和}的位置,然后截取出我们的errorSummary,再次传入parseStringValue方法

![image-20210908214043962](CVE-2016-4977/image-20210908214043962.png)

因为内部没有${}了,直接返回errorSummary,然后传入resolvPlaceholder

![image-20210908214542470](CVE-2016-4977/image-20210908214542470.png)

在后面取出我们的报错信息

![image-20210909091812846](CVE-2016-4977/image-20210909091812846.png)

因为我们的报错信息中也是包含Spel表达式的,所以又被parseStringValue拿去递归解析

![image-20210909092031750](CVE-2016-4977/image-20210909092031750.png)

然后进行相同的操作,取出我们的payload,然后交给解析器解析

![image-20210909092125895](CVE-2016-4977/image-20210909092125895.png)

成功执行命令

![image-20210909092502628](CVE-2016-4977/image-20210909092502628.png)

# 漏洞修复

![img](CVE-2016-4977/3.png)

SpelView构造方法中，加入了一个随机生成的前缀

```
this.prefix = new RandomValueStringGenerator().generate() + "{";
.
.
.
String maskedTemplate = template.replace("${", prefix);
```

render方法中，随机前缀拼接到template之前，可以这样理解`${errorSummary} -> random{errorSummary}`，由于没有递归加，所以payload没有加入random，执行前判断random，由于只有最外层符合，所以无法触发RCE

存在暴力破解的可能，因为random固定是六位。但没有价值，因为每执行一条命令都需要几万次的暴力破解请求。

# 参考

https://www.mi1k7ea.com/2020/02/09/%E6%B5%85%E6%9E%90Spring-Security-OAuth2%E4%B9%8BCVE-2016-4977/#0x01-Spring-Security-OAuth2

https://xushao.ltd/post/cve-2016-4977-fen-xi/#%E8%A1%A5%E4%B8%81%E5%88%86%E6%9E%90
